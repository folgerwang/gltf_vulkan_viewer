#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "weather_common.glsl.h"
#include "noise.glsl.h"
#include "functions.glsl.h"
#include "brdf.glsl.h"
#include "punctual.glsl.h"
#include "ibl.glsl.h"

layout(push_constant) uniform CloudLightingUniformBufferObject {
  CloudLightingParams params;
};

layout(set = VIEW_PARAMS_SET, binding = VIEW_CONSTANT_INDEX) uniform ViewUniformBufferObject {
    ViewParams view_params;
};

struct MaterialInfo
{
    float perceptualRoughness;      // roughness value, as authored by the model creator (input to shader)
    vec3 f0;                        // full reflectance color (n incidence angle)

    float alphaRoughness;           // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 albedoColor;

    vec3 f90;                       // reflectance color at grazing angle
    float metallic;

    vec3 n;
    vec3 baseColor; // getBaseColor()

    float sheenIntensity;
    vec3 sheenColor;
    float sheenRoughness;

    float anisotropy;

    vec3 clearcoatF0;
    vec3 clearcoatF90;
    float clearcoatFactor;
    vec3 clearcoatNormal;
    float clearcoatRoughness;

    float subsurfaceScale;
    float subsurfaceDistortion;
    float subsurfacePower;
    vec3 subsurfaceColor;
    float subsurfaceThickness;

    float thinFilmFactor;
    float thinFilmThickness;

    float thickness;

    vec3 absorption;

    float transmission;
};

float henyeyGreensteinPhaseFunc(float g, float cos_theta) {
    float g2 = g * g;
    return (1.0f - g2) / (pow(1.0f + g2 - 2.0f * g * cos_theta, 1.5f) * 4.0f * M_PI);
}

layout(set = 2, binding = SRC_TEMP_MOISTURE_TEX_INDEX) uniform sampler3D src_temp_moisture;
layout(set = 2, binding = SRC_CLOUD_SHADOW_TEX_INDEX) uniform sampler3D src_cloud_shadow;
layout(set = 2, binding = DST_CLOUD_LIGHTING_TEX_INDEX, r11f_g11f_b10f) uniform writeonly image3D dst_cloud_lighting;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    ivec3 pixel_coords = ivec3(gl_GlobalInvocationID.xyz);

    // bump map
    vec3 normal = vec3(0, 1, 0);

    vec3 uvw = (pixel_coords + 0.5f) * params.inv_size;
	vec3 position_ws;
	position_ws.xy = uvw.xy * params.world_range.xy + params.world_min.xy;
	position_ws.z = getSampleHeight(uvw.z, 0, params.height_params);

    vec3 albedo = vec3(1.0);

    MaterialInfo material_info;
    material_info.baseColor = albedo;

    vec3 view = normalize(position_ws - view_params.camera_pos.xyz);

    vec3 f_diffuse = vec3(0);
    vec3 f_specular = vec3(0);

    float ior = 1.5;
    float f0_ior = 0.04;

    material_info.metallic = 0.1f;//material.metallic_factor;
    material_info.perceptualRoughness = 0.95f;//material.roughness_factor;

    // Achromatic f0 based on IOR.
    vec3 f0 = vec3(f0_ior);

    material_info.albedoColor = mix(material_info.baseColor.rgb * (vec3(1.0) - f0),  vec3(0), material_info.metallic);
    material_info.f0 = mix(f0, material_info.baseColor.rgb, material_info.metallic);

    float moist_intensity = texture(src_temp_moisture, uvw).y;
    float opaque = texture(src_cloud_shadow, uvw).x;

    #ifdef USE_IBL
    float mip_count = 10;
    //f_specular += getIBLRadianceGGX(normal, view, material_info.perceptualRoughness, material_info.f0, mip_count) * clamp(1.0f - moist_intensity * 0.1f, 0.0f, 1.0f);
    //f_diffuse += getIBLRadianceLambertian(normal, material_info.albedoColor) * clamp(1.0f - moist_intensity * 0.1f, 0.0f, 1.0f);
    //f_diffuse += getIBLRadianceLambertian(-normal, material_info.albedoColor);
    #endif

    float g = 0.99f;
    float cos_theta = dot(view, -params.sun_dir);
    float phase = henyeyGreensteinPhaseFunc(g, cos_theta);

    //vec3 color = f_diffuse + f_specular;
    vec3 color = (vec3(1.0) * phase + vec3(0.5)) * (1.0f - opaque);


    imageStore(dst_cloud_lighting, pixel_coords, vec4(color, 0.0f));
}