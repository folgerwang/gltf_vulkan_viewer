#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "tile_common.glsl.h"

layout(push_constant) uniform TileUniformBufferObject {
  TileUpdateParams tile_params;
};

layout(set = 0, binding = ROCK_LAYER_BUFFER_INDEX) uniform sampler2D rock_layer;
layout(set = 0, binding = SOIL_WATER_LAYER_BUFFER_INDEX, rg16) uniform readonly image2D soil_water_layer;
layout(set = 0, binding = DST_SOIL_WATER_LAYER_BUFFER_INDEX, rg16) uniform writeonly image2D dst_soil_water_layer;
layout(set = 0, binding = DST_WATER_FLOW_BUFFER_INDEX, rg16f) uniform image2D dst_water_flow;

shared uvec2 s_terrain_layers[20][20];
shared uint s_adjust_layers[18][18];

uvec2 getPackedLayers(ivec2 src_coords) {
    vec2 uv = src_coords * tile_params.inv_width_pixel_count;
    float rock_height = texture(rock_layer, uv).x;
    vec2 soil_water_thickness = imageLoad(soil_water_layer, src_coords).xy;
    
    return uvec2(floatBitsToUint(rock_height), packUnorm2x16(soil_water_thickness));
}

vec3 unpackTerrainLayersU3(uvec2 packed_layers) {
    return vec3(uintBitsToFloat(packed_layers.x),
                unpackUnorm2x16(packed_layers.y) * 
                SOIL_WATER_LAYER_MAX_THICKNESS);
}

vec2 unpackTerrainLayersHeightU2(uvec2 packed_layers) {
    vec3 layer_thickness = unpackTerrainLayersU3(packed_layers);
    float soil_height = layer_thickness.x + layer_thickness.y;
    float water_height = layer_thickness.z + soil_height;
    return vec2(soil_height, water_height);
}

uint adjustLayersHeight(ivec2 src_coords, ivec2 global_src_coords) {
    vec2 left_h = unpackTerrainLayersHeightU2(s_terrain_layers[src_coords.y][src_coords.x - 1]);
    vec2 right_h = unpackTerrainLayersHeightU2(s_terrain_layers[src_coords.y][src_coords.x + 1]);
    vec2 up_h = unpackTerrainLayersHeightU2(s_terrain_layers[src_coords.y - 1][src_coords.x]);
    vec2 down_h = unpackTerrainLayersHeightU2(s_terrain_layers[src_coords.y + 1][src_coords.x]);
    vec3 layer_thickness = unpackTerrainLayersU3(s_terrain_layers[src_coords.y][src_coords.x]);
    float soil_height = layer_thickness.x + layer_thickness.y;
    float water_height = layer_thickness.z + soil_height;
    vec2 center_h = vec2(soil_height, water_height);
    vec2 min_h = min(min(left_h, right_h), min(up_h, down_h));

    vec2 h_diff;
    h_diff.x = center_h.x > min_h.x ? (center_h.x - min_h.x) : 0;
    h_diff.y = center_h.y > min_h.y ? (center_h.y - min_h.y) : 0;

    h_diff.x = min(h_diff.x * 0.125f, layer_thickness.y * 0.125f);
    h_diff.y = min(h_diff.y * 0.5f, layer_thickness.z * 1.2f);

    if (layer_thickness.z < 0.05f) {
        h_diff.x = 0.0f;
    }
    else {
        h_diff.x = min(h_diff.x, 0.005f);
    }

    float noise = smoothNoise(
        vec2(global_src_coords) *
        vec2(0.343, 0.434) +
        tile_params.current_time);
    h_diff.y *= (noise + 0.5f);

    uint packed_adj_height = 0;
    if (h_diff.x > 0) { // adjust soil height.
        uint idx = min_h.x == left_h.x ? 0 :
                   (min_h.x == right_h.x ? 1 : 
                   (min_h.x == up_h.x ? 2 : 3));
        packed_adj_height = (uint(h_diff.x * 1024.0f) & 0x3fff) | (idx << 14);
    }

    if (h_diff.y > 0) { // adjust water height.
        uint idx = min_h.y == left_h.y ? 0 :
                   (min_h.y == right_h.y ? 1 : 
                   (min_h.y == up_h.y ? 2 : 3));
        packed_adj_height |= ((uint(h_diff.y * 1024.0f) & 0x3fff) | (idx << 14)) << 16;
    }

    return packed_adj_height;
}

vec4 accumulateLayerLevelFromNeighbor(ivec2 src_local_coords)
{
    uint center = s_adjust_layers[src_local_coords.y][src_local_coords.x];
    uint left = s_adjust_layers[src_local_coords.y][src_local_coords.x - 1];
    uint right = s_adjust_layers[src_local_coords.y][src_local_coords.x + 1];
    uint up = s_adjust_layers[src_local_coords.y - 1][src_local_coords.x];
    uint down = s_adjust_layers[src_local_coords.y + 1][src_local_coords.x];
    uint layer_adjust = 0;

    // adjust soil layer.
    uint soil_height = 0;
    if ((left & 0x0000c000) == 0x00004000) {
        soil_height += left & 0x3fff;
    }
    if ((right & 0x0000c000) == 0x00000000) {
        soil_height += right & 0x3fff;
    }
    if ((up & 0x0000c000) == 0x0000c000) {
        soil_height += up & 0x3fff;
    }
    if ((down & 0x0000c000) == 0x00008000) {
        soil_height += down & 0x3fff;
    }

    int adj_soil_height = int(soil_height) - int(center & 0x3fff);

    // adjust water layer.
    vec2 move_vector_xz = vec2(0);
    uint water_height = 0;
    if ((left & 0xc0000000) == 0x40000000) {
        uint height_adj = (left >> 16) & 0x3fff;
        water_height += height_adj;
        float height_scale = height_adj * tile_params.flow_speed_factor.x;
        move_vector_xz += vec2(tile_params.range_per_pixel.x, 0) * height_scale;
    }
    if ((right & 0xc0000000) == 0x00000000) {
        uint height_adj = (right >> 16) & 0x3fff;
        water_height += height_adj;
        float height_scale = height_adj * tile_params.flow_speed_factor.x;
        move_vector_xz += vec2(-tile_params.range_per_pixel.x, 0) * height_scale;
    }
    if ((up & 0xc0000000) == 0xc0000000) {
        uint height_adj = (up >> 16) & 0x3fff;
        water_height += height_adj;
        float height_scale = height_adj * tile_params.flow_speed_factor.y;
        move_vector_xz += vec2(0, tile_params.range_per_pixel.y) * height_scale;
    }
    if ((down & 0xc0000000) == 0x80000000) {
        uint height_adj = (down >> 16) & 0x3fff;
        water_height += height_adj;
        float height_scale = height_adj * tile_params.flow_speed_factor.y;
        move_vector_xz += vec2(0, -tile_params.range_per_pixel.y) * height_scale;
    }

    uint flow_tag = center >> 30;
    uint center_height = (center >> 16) & 0x3fff;
    int adj_water_height = int(water_height) - int(center_height);
    float height_scale = center_height * tile_params.flow_speed_factor.y;
    move_vector_xz += 
        vec2(flow_tag == 0 ? -tile_params.range_per_pixel.x : (flow_tag == 1 ? tile_params.range_per_pixel.x : 0),
             flow_tag == 2 ? -tile_params.range_per_pixel.y : (flow_tag == 3 ? tile_params.range_per_pixel.y : 0)) *
             height_scale;

    return vec4(adj_soil_height / 1024.0f, adj_water_height / 1024.0f, move_vector_xz);
}

vec2 updateSoilWaterLayers(uint packed_layers, uint from_neighbor, uint to_neighbor)
{
    vec2 soil_water_layers = unpackUnorm2x16(packed_layers);
    ivec2 adj_layer = ivec2(from_neighbor & 0xffff, from_neighbor >> 16);
    ivec2 center = ivec2(to_neighbor & 0x3fff, (to_neighbor >> 16) & 0x3fff);
    vec2 adj_height = (adj_layer - center) / 1024.0f;

    vec2 new_soil_water_layers =
        soil_water_layers +
        adj_height *
        vec2(1.0f / SOIL_WATER_LAYER_MAX_THICKNESS);

    return mix(soil_water_layers, new_soil_water_layers, 0.8f);
}

layout(local_size_x = 16, local_size_y = 16) in;
void main()
{
  // get index in global work group i.e x,y position
  int buffer_size = int(tile_params.width_pixel_count);
  // skip 2 lines on border.
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  ivec2 local_coords = ivec2(gl_LocalInvocationID.xy);
  ivec2 block_coords = ivec2(gl_WorkGroupID.xy) * 16;
  uint pixel_index = gl_LocalInvocationIndex;

  if (pixel_index < 10 * 20) {
    ivec2 src_local_coords = ivec2((pixel_index % 10) * 2, pixel_index / 10);
    ivec2 src_coords = clamp(src_local_coords + block_coords - 2,
                             0,
                             buffer_size - 1);
    s_terrain_layers[src_local_coords.y][src_local_coords.x] = getPackedLayers(src_coords);

    src_coords = clamp(src_local_coords + ivec2(1, 0) + block_coords - 2,
                       0,
                       buffer_size - 1);
    s_terrain_layers[src_local_coords.y][src_local_coords.x + 1] = getPackedLayers(src_coords);
  }

  barrier();
  memoryBarrierShared();

  if (pixel_index < 9 * 18) {
    ivec2 src_local_coords = ivec2((pixel_index % 9) * 2, pixel_index / 9);
    s_adjust_layers[src_local_coords.y][src_local_coords.x] = 
      adjustLayersHeight(src_local_coords + 1,
                         src_local_coords + 1 + block_coords - 1);

    s_adjust_layers[src_local_coords.y][src_local_coords.x + 1] = 
      adjustLayersHeight(src_local_coords + ivec2(1, 0) + 1,
                         src_local_coords + ivec2(1, 0) + 1 + block_coords - 1);
  }

  barrier();
  memoryBarrierShared();

  if (all(lessThan(pixel_coords, uvec2(tile_params.width_pixel_count)))) {
    vec2 move_vector_xz = vec2(0);
    vec4 layer_adjust = accumulateLayerLevelFromNeighbor(local_coords + 1);
    ivec2 src_local_coords = local_coords + 2;
    uvec2 packed_layers = s_terrain_layers[src_local_coords.y][src_local_coords.x];
    vec2 soil_water_layers = unpackUnorm2x16(packed_layers.y) +
        layer_adjust.xy * vec2(1.0f / SOIL_WATER_LAYER_MAX_THICKNESS) * 0.8f;
    imageStore(dst_soil_water_layer, pixel_coords, vec4(soil_water_layers, 0, 0));
    vec4 current_flow = imageLoad(dst_water_flow, pixel_coords);
    imageStore(dst_water_flow, pixel_coords, vec4(mix(layer_adjust.zw, current_flow.xy, 0.5), 0, 0));
  }
}