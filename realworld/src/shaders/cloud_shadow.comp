#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "weather_common.glsl.h"
#include "noise.glsl.h"
#include "functions.glsl.h"
#include "brdf.glsl.h"
#include "punctual.glsl.h"
#include "ibl.glsl.h"

layout(push_constant) uniform CloudLightingUniformBufferObject {
  CloudShadowParams params;
};

vec2 mirrorRepeat(vec2 src_coord, vec2 size) {
    vec2 scr_coord_mod = mod(src_coord, 2.0f * size);
    if (scr_coord_mod.x > size.x) {
        scr_coord_mod.x = 2.0f * size.x - scr_coord_mod.x;
    }
    if (scr_coord_mod.y > size.y) {
        scr_coord_mod.y = 2.0f * size.y - scr_coord_mod.y;
    }

    return scr_coord_mod;
}

layout(set = 0, binding = SRC_TEMP_MOISTURE_TEX_INDEX) uniform sampler3D src_temp_moisture;
layout(set = 0, binding = DST_CLOUD_SHADOW_TEX_INDEX, r8) uniform image3D dst_cloud_shadow;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    ivec3 pixel_coords = ivec3(gl_GlobalInvocationID.xy, params.size.z - 1 - params.layer_idx);

    // bump map
    vec3 normal = vec3(0, 1, 0);

    vec3 uvw = (pixel_coords + 0.5f) * params.inv_size;
	vec3 position_ws;
	position_ws.xz = uvw.xy * params.world_range.xy + params.world_min.xy;
	position_ws.y = getSampleHeight(uvw.z, 0, params.height_params);

    float src_opaque = 0.0f;
    // from top to bottom.
    if (params.layer_idx > 0) {
        vec3 upper_uvw;
        upper_uvw.z = uvw.z + params.inv_size.z;

        float upper_layer_height = getSampleHeight(upper_uvw.z, 0, params.height_params);
        float height_diff = upper_layer_height - position_ws.y;
        float sample_dist = height_diff * length(params.sun_dir) / abs(params.sun_dir.y);

        vec3 upper_layer_position_ws = position_ws.xzy + params.sun_dir * sample_dist;

        upper_uvw.xy = (upper_layer_position_ws.xz - params.world_min.xy) * params.inv_world_range.xy;

        vec2 upper_pixel_coord = mirrorRepeat(upper_uvw.xy * params.size.xy, params.size.xy);
        vec2 noise = hash23(vec3(upper_pixel_coord, pixel_coords.z + 1));
        vec2 upc_ratio = fract(noise + upper_pixel_coord);
        ivec2 upc = ivec2(upper_pixel_coord);

        float src_opaque_00 = imageLoad(dst_cloud_shadow, ivec3(upc, pixel_coords.z + 1)).x;
        float src_opaque_01 = imageLoad(dst_cloud_shadow, ivec3(upc+ivec2(1, 0), pixel_coords.z + 1)).x;
        float src_opaque_10 = imageLoad(dst_cloud_shadow, ivec3(upc+ivec2(0, 1), pixel_coords.z + 1)).x;
        float src_opaque_11 = imageLoad(dst_cloud_shadow, ivec3(upc+ivec2(1, 1), pixel_coords.z + 1)).x;

        src_opaque = mix(mix(src_opaque_00, src_opaque_01, upc_ratio.x), mix(src_opaque_10, src_opaque_11, upc_ratio.x), upc_ratio.y);
    }

    float cur_moist = texture(src_temp_moisture, uvw).y * params.opaque_scale;

    imageStore(dst_cloud_shadow, pixel_coords, vec4(cur_moist + src_opaque));
}