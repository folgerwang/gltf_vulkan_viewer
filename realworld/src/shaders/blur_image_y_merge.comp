#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"

layout(push_constant) uniform BlurImageUniformBufferObject {
    BlurImageParams params;
};

layout(set = 0, binding = SRC_TEX_INDEX) uniform sampler2D src_img;
layout(set = 0, binding = DST_TEX_INDEX, r11f_g11f_b10f) uniform image2D dst_img;

shared vec4 s_src_color[80];
layout(local_size_x = 1, local_size_y = 64) in;
void main()
{
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 local_coords = ivec2(gl_LocalInvocationID.xy);
	ivec2 block_coords = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y * 64);
	uint pixel_index = gl_LocalInvocationIndex;

	if (pixel_index < 40) {
		ivec2 slc = ivec2(0, local_coords.y * 2);
		ivec2 sgc = clamp(slc + block_coords + ivec2(0, -8),
                             ivec2(0),
                             ivec2(params.size - 1));
	    s_src_color[slc.y] = texture(src_img, (sgc + 0.5) * params.inv_size);
		s_src_color[slc.y+1] = texture(src_img, (sgc + vec2(0.5, 1.5)) * params.inv_size);
	}

	barrier();
    memoryBarrierShared();

	if (pixel_coords.y < params.size.y) {
		vec4 sum_color = s_src_color[local_coords.y+8];
		float sum_weight = 1.0f;

		for (int i = 1; i <= 8; i++) {
			float weight = 1.0f / i;
			sum_color += (s_src_color[local_coords.y+8-i] + s_src_color[local_coords.y+8+i]) * weight;
			sum_weight += weight * 2.0f;
		}
		vec4 fog_color = sum_color / sum_weight;
  
		vec4 src_color = imageLoad(dst_img, pixel_coords);
		vec3 dst_color = src_color.xyz * fog_color.w + fog_color.xyz;

		// output to a specific pixel in the image.
		imageStore(dst_img, pixel_coords, vec4(dst_color, src_color.w));
	}
}