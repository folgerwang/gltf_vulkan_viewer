#version 450
#extension GL_ARB_separate_shader_objects : enable

#define RENDER_SUNLIGHT_SCATTERING  1
const int iSteps = 16;
const int jSteps = 8;

#include "global_definition.glsl.h"
#include "noise.glsl.h"
#include "weather_common.glsl.h"
#include "sunlight_scattering.glsl.h"

layout(push_constant) uniform VolumeMoistUniformBufferObject {
    VolumeMoistrueParams params;
};

layout(set = VIEW_PARAMS_SET, binding = VIEW_CONSTANT_INDEX) uniform ViewUniformBufferObject {
    ViewParams view_params;
};

layout(set = 0, binding = SRC_TEMP_MOISTURE_INDEX) uniform sampler3D src_temp_moist;
layout(set = 0, binding = SRC_CLOUD_LIGHTING_TEX_INDEX) uniform sampler3D src_cloud_lighting;
layout(set = 0, binding = SRC_DEPTH_TEX_INDEX) uniform sampler2D src_depth;
layout(set = 0, binding = DST_FOG_CLOUD_INDEX, rgba16f) uniform writeonly image2D dst_fog_cloud;

layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 in_uv = (pixel_coords + 0.5) * params.inv_screen_size;
    vec2 ss_xy = in_uv * 2.0f - 1.0f;
    vec4 position_ss = vec4(ss_xy, -1.0f * view_params.proj[2][2] + view_params.proj[3][2], 1.0f);
    vec3 view_dir = normalize((view_params.inv_view_proj_relative * position_ss).xyz);
    float view_vec_length = length(view_dir);

    float depth_z = texture(src_depth, in_uv).r;
    float dist_scale = length(vec3(ss_xy * view_params.depth_params.zw, 1.0f));
    float bg_view_dist = view_params.proj[3].z / (depth_z + view_params.proj[2].z) * dist_scale;

    float cast_dist = 10000.0f;
    if (view_dir.y > 0) {
        cast_dist = max(kAirflowMaxHeight - view_params.camera_pos.y, 0.0f) / view_dir.y * view_vec_length;
    }
    else if (view_dir.y < 0) {
        cast_dist = max(view_params.camera_pos.y - kAirflowLowHeight, 0.0f) / abs(view_dir.y) * view_vec_length;
    }

    cast_dist = min(cast_dist, bg_view_dist);
        
    vec2 noise = hash23(floor(view_dir * 1334.0f));
    vec3 noise_dir = hash33(floor(view_dir * 1434.0f)) * 2.0f - 1.0f;
    view_dir = normalize(view_dir + noise_dir * 0.0089f);
    float dither = (1.0f + (noise.y * 2.0f - 1.0f) * 0.2f);

    vec3 fog_color = vec3(0);
#if RENDER_SUNLIGHT_SCATTERING
    vec3 r = view_dir;
    vec3 r0 = vec3(0, kPlanetRadius, 0) + view_params.camera_pos.xyz;
    float g = params.g;
    float cast_range = cast_dist;
    fog_color += atmosphereLut(
        r,                              // normalized ray direction
        r0,                             // ray origin
        cast_range,
        normalize(params.sun_pos),      // position of the sun
        22.0,                           // intensity of the sun
        kPlanetRadius,                  // radius of the planet in meters
        kAtmosphereRadius,              // radius of the atmosphere in meters
        vec3(5.5e-6, 13.0e-6, 22.4e-6), // Rayleigh scattering coefficient
        21e-6,                          // Mie scattering coefficient
        params.inv_rayleigh_scale_height,           // Rayleigh scale height
        params.inv_mie_scale_height,                // Mie scale height
        g,                              // Mie preferred scattering direction
        vec2(1.0f, 1.0f),
        iSteps).xyz;
#endif

    vec3 fg_color = vec3(0);
    float final_alpha = 1.0f;
    float last_dist = cast_dist / 32.0f * (32 + noise.x);
    for (int i = 0; i < 32; i++) {
        float cur_dist = cast_dist / 32.0f * (32 - i + noise.x);
        float thickness = max(last_dist - cur_dist, 0.0f);

        vec3 sample_pos = view_params.camera_pos.xyz + cur_dist * view_dir;

        vec3 uvw;
        uvw.z = getHeightToSample(sample_pos.y);

        uvw.xy = (sample_pos.xz - params.world_min) * params.inv_world_range;
        vec2 temp_moisture = texture(src_temp_moist, uvw).xy;
        float moist = denormalizeMoisture(temp_moisture.y);
        vec3 cloud_lighting = texture(src_cloud_lighting, uvw).xyz;

        float cur_alpha = exp2(-thickness * moist * 0.02f * dither);
        fg_color = mix(cloud_lighting/* * fog_color*/, fg_color, cur_alpha);
        final_alpha *= cur_alpha;

        last_dist = cur_dist;
    }

    imageStore(dst_fog_cloud, pixel_coords, vec4(fg_color, final_alpha));
}
