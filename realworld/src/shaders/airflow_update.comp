#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "tile_common.glsl.h"

layout(push_constant) uniform AirflowUniformBufferObject {
  AirflowUpdateParams params;
};

layout(set = 0, binding = DST_TEMPERATURE_TEX_INDEX, r16f) uniform writeonly image3D dst_temperature;
layout(set = 0, binding = SRC_TEMPERATURE_TEX_INDEX, r16f) uniform readonly image3D src_temperature;
layout(set = 0, binding = ROCK_LAYER_BUFFER_INDEX) uniform sampler2D rock_layer;
layout(set = 0, binding = SOIL_WATER_LAYER_BUFFER_INDEX) uniform sampler2D soil_water_layer;

shared vec2 s_ground_info[12][12];
shared uint s_temperature_grid[12][12][6];
shared uint s_airflow_grid[10][10][5];

vec2 getPackedLayers(vec2 uv) {
    float rock_height = texture(rock_layer, uv).x;
    vec2 soil_water_thickness = 
        texture(soil_water_layer, uv).xy * SOIL_WATER_LAYER_MAX_THICKNESS;

    float soil_layer_height = rock_height + soil_water_thickness.x;
    float water_layer_height = soil_layer_height + soil_water_thickness.y;
    
    return vec2(soil_layer_height, water_layer_height);
}

vec4 getPositionWS(vec3 uvw) {
    vec4 position_ws;
    position_ws.xy = uvw.xy * params.world_range.xy + params.world_min.xy;
    position_ws.z = exp2((uvw.z - params.inv_size.z * 0.5f) * log2(1.0f + params.world_range.z)) - 1.0f + params.world_min.z;
    position_ws.w = exp2((uvw.z + params.inv_size.z * 0.5f) * log2(1.0f + params.world_range.z)) - 1.0f + params.world_min.z;
    return position_ws;
}

float getUpdatedTemperature(ivec3 src_local_coords, ivec3 block_coords, vec2 ground_info) {
    ivec3 src_coords = clamp(src_local_coords + block_coords - 2,
                             ivec3(0),
                             params.size - 1);
    float src_temp = imageLoad(src_temperature, src_coords).x;
    vec4 position_ws = getPositionWS((src_coords + 0.5) * params.inv_size);
    float water_depth = ground_info.y - ground_info.x;
    bool cell_touch_ground = (ground_info.y >= position_ws.z - 0.01f);// && (ground_info.y <= position_ws.w + 0.01f);
    bool cell_above_ground = ground_info.y < position_ws.z;
    float temp_adjust = 0.0f;
    if (cell_touch_ground) {
        temp_adjust += mix(0.1f, 0.05f, clamp(water_depth * 10.0f, 0.0f, 1.0f));
    }
    else if (cell_above_ground) {
        temp_adjust += 0.001f;
    }
    return src_temp + temp_adjust;
}

uint packTempDiff(uint min_temp, float center) {
     float min_t = unpackHalf2x16(min_temp).y;

     uint temp_diff = 0;
     if (center > min_t) {
        temp_diff = uint(min((center - min_t) * 0.5f, 7.9f) * 1024.0f);
        temp_diff |= (min_temp & 0x0f) << 13;
     }

     return temp_diff;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main()
{
  ivec3 buffer_size = ivec3(params.size);

  ivec3 pixel_coords = ivec3(gl_GlobalInvocationID.xyz);
  ivec3 local_coords = ivec3(gl_LocalInvocationID.xyz);
  ivec3 block_coords = ivec3(gl_WorkGroupID.xyz) * 8;
  int pixel_index = int(gl_LocalInvocationIndex);

  if (pixel_index < 12 * 12) {
     ivec2 src_local_coords = ivec2(pixel_index % 12, pixel_index / 12);
     ivec2 src_coords = clamp(src_local_coords + block_coords.xy - 2,
                        ivec2(0),
                        buffer_size.xy - 1);
     s_ground_info[src_local_coords.y][src_local_coords.x] =
            getPackedLayers((src_coords + 0.5) * params.inv_size.xy);
  }

  barrier();
  memoryBarrierShared();

  if (pixel_index < 6 * 12 * 6) {
     int iz = pixel_index / (12 * 6);
     int ixy = pixel_index % (12 * 6);
     ivec3 src_local_coords_0 = ivec3((ixy % 6) * 2, ixy / 6, iz);
     ivec3 src_local_coords_1 = src_local_coords_0;
     src_local_coords_1.x += 1;

     vec2 ground_info_0 = s_ground_info[src_local_coords_0.y][src_local_coords_0.x];
     vec2 ground_info_1 = s_ground_info[src_local_coords_1.y][src_local_coords_1.x];

     float t0 = getUpdatedTemperature(src_local_coords_0, block_coords, ground_info_0);
     float t1 = getUpdatedTemperature(src_local_coords_1, block_coords, ground_info_1);
     s_temperature_grid[src_local_coords_0.z][src_local_coords_0.y][src_local_coords_0.x / 2] =
        packHalf2x16(vec2(t0, t1));
     
     src_local_coords_0.z += 6;
     src_local_coords_1.z += 6;
     t0 = getUpdatedTemperature(src_local_coords_0, block_coords, ground_info_0);
     t1 = getUpdatedTemperature(src_local_coords_1, block_coords, ground_info_1);
     s_temperature_grid[src_local_coords_0.z][src_local_coords_0.y][src_local_coords_0.x / 2] =
        packHalf2x16(vec2(t0, t1));
  }

  barrier();
  memoryBarrierShared();

  if (pixel_index < 10 * 10 * 5) {
     int iz = pixel_index / (10 * 5);
     int ixy = pixel_index % (10 * 5);

     ivec3 dlc = ivec3(ixy % 5, ixy / 5, iz);
     ivec3 slc = dlc + ivec3(0, 1, 1);

     uint c0 = s_temperature_grid[slc.z][slc.y][slc.x];
     uint c1 = s_temperature_grid[slc.z][slc.y][slc.x+1];

     uint cc0 = c0 & 0xffff0000;
     vec2 center = unpackHalf2x16(cc0 | (c1 & 0x0000ffff));

     uint left = c0 << 16;
     uint right = (c1 << 16) | 0x01;
     uint back = (s_temperature_grid[slc.z][slc.y-1][slc.x] & 0xffff0000) | 0x02;
     uint front = (s_temperature_grid[slc.z][slc.y+1][slc.x] & 0xffff0000) | 0x03;
     uint top = (s_temperature_grid[slc.z-1][slc.y][slc.x] & 0xffff0000) | 0x04;
     uint bottom = (s_temperature_grid[slc.z+1][slc.y][slc.x] & 0xffff0000) | 0x05;

     uint min_value = min(min(min(left, right), min(back, front)), min(top, bottom));
     uint diff0 = packTempDiff(min_value, center.y);

     left = cc0;
     right = (c1 & 0xffff0000) | 0x01;
     back = (s_temperature_grid[slc.z][slc.y-1][slc.x+1] << 16) | 0x02;
     front = (s_temperature_grid[slc.z][slc.y+1][slc.x+1] << 16) | 0x03;
     top = (s_temperature_grid[slc.z-1][slc.y][slc.x+1] << 16) | 0x04;
     bottom = (s_temperature_grid[slc.z+1][slc.y][slc.x+1] << 16) | 0x05;

     min_value = min(min(min(left, right), min(back, front)), min(top, bottom));
     uint diff1 = packTempDiff(min_value, center.x);

     s_airflow_grid[dlc.z][dlc.y][dlc.x] = (diff1 << 16) | diff0;
  }

  barrier();
  memoryBarrierShared();
  int slot_idx = local_coords.x % 2;
  int shift_bits = slot_idx > 0 ? 0 : 16;
  int lr_shift_bits = 16 - shift_bits;

  ivec3 slc = ivec3(local_coords.x / 2, local_coords.y + 1, local_coords.z + 1);
  uint c0 = s_airflow_grid[slc.z][slc.y][slc.x];
  uint c1 = s_airflow_grid[slc.z][slc.y][slc.x+1];
  slc.x += slot_idx;
  uint back = s_airflow_grid[slc.z][slc.y-1][slc.x] >> shift_bits;
  uint front = s_airflow_grid[slc.z][slc.y+1][slc.x] >> shift_bits;
  uint top = s_airflow_grid[slc.z-1][slc.y][slc.x] >> shift_bits;
  uint bottom = s_airflow_grid[slc.z+1][slc.y][slc.x] >> shift_bits;
  uint left = c0 >> lr_shift_bits;
  uint right = c1 >> lr_shift_bits;

  int temp_flow = 0;
  if ((back & 0xe000) == 0x6000) {
    temp_flow += int(back & 0x1fff);
  }
  if ((front & 0xe000) == 0x4000) {
    temp_flow += int(front & 0x1fff);
  }
  if ((top & 0xe000) == 0xa000) {
    temp_flow += int(top & 0x1fff);
  }
  if ((bottom & 0xe000) == 0x8000) {
    temp_flow += int(bottom & 0x1fff);
  }
  if ((left & 0xe000) == 0x2000) {
    temp_flow += int(left & 0x1fff);
  }
  right &= 0xffff;
  if (right > 0 && (right & 0xe000) == 0x0000) {
    temp_flow += int(right & 0x1fff);
  }

  if (slot_idx == 1) {
    c0 = c1;
  }

  uint center = c0 >> shift_bits;
  temp_flow -= int(center & 0x1fff);

  // skip 2 lines on border.
  uint packed_temp = s_temperature_grid[local_coords.z+2][local_coords.y+2][local_coords.x/2+1];
  vec2 t = unpackHalf2x16(packed_temp);

  if (slot_idx == 1) {
    t.x = t.y;
  }   

  t.x += temp_flow / 1024.0f;

  imageStore(dst_temperature, pixel_coords, vec4(t.x));
}