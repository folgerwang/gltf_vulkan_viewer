#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "weather_common.glsl.h"
#include "tile_common.glsl.h"
#include "noise.glsl.h"

layout(push_constant) uniform AirflowUniformBufferObject {
  AirflowUpdateParams params;
};

layout(set = 0, binding = DST_TEMP_MOISTURE_TEX_INDEX, rg16) uniform writeonly image3D dst_temp_moisture;
layout(set = 0, binding = SRC_TEMP_MOISTURE_TEX_INDEX, rg16) uniform readonly image3D src_temp_moisture;
layout(set = 0, binding = DST_AIRFLOW_TEX_INDEX, rgba8) uniform image3D dst_airflow;
layout(set = 0, binding = ROCK_LAYER_BUFFER_INDEX) uniform sampler2D rock_layer;
layout(set = 0, binding = SOIL_WATER_LAYER_BUFFER_INDEX) uniform sampler2D soil_water_layer;

shared vec2 s_ground_info[12][12];
shared uint s_air_pressure_grid[20][12][12];
shared uint s_flow_grid[18][10][10];

vec2 getPackedLayers(vec2 uv) {
    vec2 layer_height = vec2(-10.0f, 0.0f);

    if (uv.x >= 0.0f && uv.x <= 1.0f && uv.y >= 0.0f && uv.y <= 1.0f) {
        float rock_height = texture(rock_layer, uv).x;
        vec2 soil_water_thickness = 
            texture(soil_water_layer, uv).xy * SOIL_WATER_LAYER_MAX_THICKNESS;

        float soil_layer_height = rock_height + soil_water_thickness.x;
        float water_layer_height = soil_layer_height + soil_water_thickness.y;
    
        layer_height = vec2(soil_layer_height, water_layer_height);
    }

    return layer_height;
}

uint packTempMoist(float temp, float moist, uint tag) {
    temp /= kMaxTemperatureAdjustRange;
    moist /= kMaxMoistureIntensity;
    uint packed_moist_temp = 
        packUnorm2x16(vec2(
            moist,
            temp * 0.5f + 0.5f));
    packed_moist_temp = (packed_moist_temp & 0xfffffff8) | (tag & 0x07);
    return packed_moist_temp;
}

vec2 unpackTempMoist(uint packed_temp_moist) {
    vec2 snorm_moist_temp = unpackUnorm2x16(packed_temp_moist & 0xfffffff8);
    return vec2((snorm_moist_temp.y * 2.0f - 1.0f) * kMaxTemperatureAdjustRange,
                snorm_moist_temp.x * kMaxMoistureIntensity);
}

uint packTempMoistDiff(float temp, float moist, uint tag) {
    uint temp_moist_diff = packUnorm2x16(vec2(moist, temp) / kMaxTempMoistDiff);
    temp_moist_diff = (temp_moist_diff & 0xfffffff8) | (tag & 0x07);
    return temp_moist_diff;
}

uint getAirPressure(ivec3 slc, ivec3 block_coords, vec2 ground_info) {
    ivec3 src_coords = clamp(slc + block_coords - 2,
                             ivec3(0),
                             params.size - 1);

    float noise = hash13(vec3(src_coords) + params.current_time);

    vec2 src_temp_moist = imageLoad(src_temp_moisture, src_coords).xy;
    float src_temp = denormalizeTemperature(src_temp_moist.x);
    float src_moist = denormalizeMoisture(src_temp_moist.y);

    float uvw_w = (src_coords.z + 0.5f) * params.inv_size.z;
    float sample_h = getSampleToHeight(uvw_w);

    // add some noise for contact detection.
    float low_uvw_w = uvw_w + (noise - 1.0f) * params.inv_size.z;
    float min_h = getSampleToHeight(low_uvw_w);

    float water_depth = ground_info.y - ground_info.x;
    bool cell_touch_ground = (ground_info.y >= min_h - 0.01f);
    float temp_adjust = 0.0f;
    uint u_water_level = 255;
    if (cell_touch_ground) {
        float water_level = clamp((water_depth - 0.01f) * 10.0f, 0.0f, 1.0f);
        water_level = floor(water_level * 254.0f);
        u_water_level = uint(water_level);
        temp_adjust += mix(params.controls.soil_temp_adj, params.controls.water_temp_adj, water_level / 254.0f);
    }
    else {
        temp_adjust += params.controls.moist_temp_convert * src_moist;
    }

    float air_pressure = getAirPressure(params.controls.sea_level_temperature + temp_adjust, sample_h);
    uint u_air_pressure = uint(air_pressure * 2097152.0f);

    return (u_air_pressure << 11) | (u_water_level << 3);
}

void updateAirPressureBuffer(int pixel_index, ivec3 block_coords) {
    int iz = pixel_index / (12 * 12);
    int ixy = pixel_index % (12 * 12);
    ivec3 slc = ivec3(ixy % 12, ixy / 12, iz);

    vec2 ground_info = s_ground_info[slc.y][slc.x];

    uint temp_moist = getAirPressure(slc, block_coords, ground_info);
    s_air_pressure_grid[slc.z][slc.y][slc.x] = temp_moist;
}

vec2 loadAndUpdateTempMoist(ivec3 pixel_coords, uint air_pressure_info)
{
    vec2 src_temp_moist = imageLoad(src_temp_moisture, pixel_coords).xy;
    float src_temp = denormalizeTemperature(src_temp_moist.x);
    float src_moist = denormalizeMoisture(src_temp_moist.y);

    uint u_water_level = (air_pressure_info >> 3) & 0xff;
    float temp_adjust = 0.0f;
    float moist_adjust = 0.0f;
    if (u_water_level < 255) {
        float water_level = u_water_level / 254.0f;
        temp_adjust += mix(params.controls.soil_temp_adj, params.controls.water_temp_adj, water_level);
        moist_adjust += mix(params.controls.soil_moist_adj, params.controls.water_moist_adj, water_level);
    }
    else {
        temp_adjust += params.controls.moist_temp_convert * src_moist;
    }

    src_temp += temp_adjust;
    src_moist += moist_adjust;

    return vec2(src_temp, src_moist);
}

uint packTempMoistChanges(uint min_air_pressure, uint center, ivec3 pixel_coords) {
    float center_air_pressure = float(center >> 11);
    float target_air_pressure = float(min_air_pressure >> 11);
    uint flow_tag = min_air_pressure & 0x07;
    uint packed_temp_moist_diff = 0;

    if (center_air_pressure > target_air_pressure) {
        ivec3 min_pixel_coords = pixel_coords +
                                 ivec3(flow_tag == kNodeLeft ? -1 : (flow_tag == kNodeRight ? 1 : 0),
                                       flow_tag == kNodeBack ? -1 : (flow_tag == kNodeFront ? 1 : 0),
                                       flow_tag == kNodeBelow ? -1 : (flow_tag == kNodeAbove ? 1 : 0));

        vec2 center_temp_moist = loadAndUpdateTempMoist(pixel_coords, center);
        vec2 min_temp_moist = loadAndUpdateTempMoist(min_pixel_coords, min_air_pressure);

        float air_pressure_diff = (center_air_pressure - target_air_pressure) / 2097152.0f;
        float airflow_speed = sqrt(air_pressure_diff);
        float transfer_ratio = clamp(airflow_speed * 32.0f, 0.0f, 1.0f);
        vec2 temp_moist_diff = center_temp_moist - min_temp_moist;

        vec4 noise_values = hash44(vec4(vec3(pixel_coords), params.current_time)) * 2.0f - 1.0f;

        float uvw_w = (pixel_coords.z + 0.5) * params.inv_size.z;
        float sample_h = getSampleToHeight(uvw_w);
        float target_stable_temp = getReferenceDegree(params.controls.sea_level_temperature, sample_h) + center_temp_moist.x;

        float frozen_rate = (target_stable_temp - 15.0f) / 10.0f * 0.5f + 0.5f;
        float frozen_transfer_rate = clamp(frozen_rate + noise_values.z * 0.3f, 0.0f, 1.0f);

        float temp_transfer = params.controls.heat_transfer_ratio * (1.0f + noise_values.x * params.controls.heat_transfer_noise_weight);
        float moist_transfer = params.controls.moist_transfer_ratio * (1.0f + noise_values.y * params.controls.moist_transfer_noise_weight) * frozen_transfer_rate;

        temp_moist_diff *= vec2(temp_transfer, moist_transfer) * transfer_ratio;
        vec2 temp_moist_diff_normalized = temp_moist_diff / kMaxTempMoistDiff * 0.5f + 0.5f;
        uint u_temp_moist_diff = packUnorm2x16(temp_moist_diff_normalized.yx);
        packed_temp_moist_diff = (u_temp_moist_diff & 0xfffffff8) | (min_air_pressure & 0x07);
    }

    return packed_temp_moist_diff;
}

void createAirflowBuffer(int pixel_index, ivec3 block_coords) {
    int iz = pixel_index / (10 * 10);
    int ixy = pixel_index % (10 * 10);

    ivec3 dlc = ivec3(ixy % 10, ixy / 10, iz);
    ivec3 slc = dlc + 1;

    ivec3 pixel_coords = clamp(dlc + block_coords - 1,
                               ivec3(0),
                               params.size - 1);

    uint center = s_air_pressure_grid[slc.z][slc.y][slc.x];

    uint left = s_air_pressure_grid[slc.z][slc.y][slc.x-1] | kNodeLeft;
    uint right = s_air_pressure_grid[slc.z][slc.y][slc.x+1] | kNodeRight;
    uint back = s_air_pressure_grid[slc.z][slc.y-1][slc.x] | kNodeBack;
    uint front = s_air_pressure_grid[slc.z][slc.y+1][slc.x] | kNodeFront;
    uint below = s_air_pressure_grid[slc.z-1][slc.y][slc.x] | kNodeBelow;
    uint above = s_air_pressure_grid[slc.z+1][slc.y][slc.x] | kNodeAbove;

    uint min_air_pressure = min(min(min(left, right), min(back, front)), min(below, above));

    s_flow_grid[dlc.z][dlc.y][dlc.x] = packTempMoistChanges(min_air_pressure, center, pixel_coords);
}

vec2 generateAirflow(ivec3 dlc, out vec3 airflow_dir, float above_ratio, float below_ratio) {
    ivec3 slc = dlc + 1;
    uint center = s_flow_grid[slc.z][slc.y][slc.x];

    uint left = s_flow_grid[slc.z][slc.y][slc.x-1];
    uint right = s_flow_grid[slc.z][slc.y][slc.x+1];
    uint back = s_flow_grid[slc.z][slc.y-1][slc.x];
    uint front = s_flow_grid[slc.z][slc.y+1][slc.x];
    uint below = s_flow_grid[slc.z-1][slc.y][slc.x];
    uint above = s_flow_grid[slc.z+1][slc.y][slc.x];

    vec2 moist_temp_adj = vec2(0);
    vec3 airflow_vec = vec3(0);
    if (left != 0 && (left & 0x07) == kNodeRight) {
        vec2 moist_temp_trans = unpackUnorm2x16(left & 0xfffffff8) * 2.0f - 1.0f;
        moist_temp_adj += moist_temp_trans;
        airflow_vec += vec3(moist_temp_trans.y, 0, 0);
    }
    if (right != 0 && (right & 0x07) == kNodeLeft) {
        vec2 moist_temp_trans = unpackUnorm2x16(right & 0xfffffff8) * 2.0f - 1.0f;
        moist_temp_adj += moist_temp_trans;
        airflow_vec += vec3(-moist_temp_trans.y, 0, 0);
    }
    if (back != 0 && (back & 0x07) == kNodeFront) {
        vec2 moist_temp_trans = unpackUnorm2x16(back & 0xfffffff8) * 2.0f - 1.0f;
        moist_temp_adj += moist_temp_trans;
        airflow_vec += vec3(0, 0, moist_temp_trans.y);
    }
    if (front != 0 && (front & 0x07) == kNodeBack) {
        vec2 moist_temp_trans = unpackUnorm2x16(front & 0xfffffff8) * 2.0f - 1.0f;
        moist_temp_adj += moist_temp_trans;
        airflow_vec += vec3(0, 0, -moist_temp_trans.y);
    }
    if (below != 0 && (below & 0x07) == kNodeAbove) {
        vec2 moist_temp_trans = (unpackUnorm2x16(below & 0xfffffff8) * 2.0f - 1.0f) * below_ratio;
        moist_temp_adj += moist_temp_trans;
        airflow_vec += vec3(0, moist_temp_trans.y, 0);
    }
    if (above != 0 && (above & 0x07) == kNodeBelow) {
        vec2 moist_temp_trans = (unpackUnorm2x16(above & 0xfffffff8) * 2.0f - 1.0f) * above_ratio;
        moist_temp_adj += moist_temp_trans;
        airflow_vec += vec3(0, -moist_temp_trans.y, 0);
    }

    if (center != 0) {
        uint flow_tag = center & 0x07;
        vec2 moist_temp_trans = unpackUnorm2x16(center & 0xfffffff8) * 2.0f - 1.0f;

        airflow_vec += vec3(flow_tag == kNodeLeft ? -1.0f : (flow_tag == kNodeRight ? 1.0f : 0),
                            flow_tag == kNodeBelow ? -1.0f : (flow_tag == kNodeAbove ? 1.0f : 0),
                            flow_tag == kNodeBack ? -1.0f : (flow_tag == kNodeFront ? 1.0f : 0)) * moist_temp_trans.y;
        moist_temp_adj -= moist_temp_trans;
    }

    airflow_dir = vec3(airflow_vec) * kMaxTempMoistDiff;
    vec2 temp_moist_adj = moist_temp_adj.yx * kMaxTempMoistDiff;
    return temp_moist_adj;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 16) in;
void main()
{
    ivec3 pixel_coords = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 local_coords = ivec3(gl_LocalInvocationID.xyz);
    ivec3 block_coords = ivec3(gl_WorkGroupID.xyz) * ivec3(8, 8, 16);
    int pixel_index = int(gl_LocalInvocationIndex);

    if (pixel_index < 12 * 12) {
        ivec2 slc = ivec2(pixel_index % 12, pixel_index / 12);
        ivec2 src_coords = clamp(slc + block_coords.xy - 2,
                                 ivec2(0),
                                 params.size.xy - 1);
        vec2 uv = (src_coords + 0.5) * params.inv_size.xy;
        s_ground_info[slc.y][slc.x] =
            getPackedLayers((uv - 0.5f) * 2.0f + 0.5f);
    }

    barrier();
    memoryBarrierShared();

    if (pixel_index < (20 * 12 * 12 / 3)) {
        for (int i = 0; i < 3; i++) {
            updateAirPressureBuffer(pixel_index * 3 + i, block_coords);
        }
    }

    barrier();
    memoryBarrierShared();

    if (pixel_index < (18 * 10 * 10 / 2)) {
        for (int i = 0; i < 2; i++) {
            createAirflowBuffer(pixel_index * 2 + i, block_coords);
        }
    }

    barrier();
    memoryBarrierShared();

    vec3 airflow_dir;
    float uvw_w = (pixel_coords.z + 0.5) * params.inv_size.z;
    float sample_delta_h = getSampleToDeltaHeight(uvw_w);
    float above_sample_delta_h = getSampleToDeltaHeight(uvw_w + params.inv_size.z);
    float below_sample_delta_h = getSampleToDeltaHeight(uvw_w - params.inv_size.z);
    vec2 temp_moist_adj = generateAirflow(local_coords,
                                          airflow_dir,
                                          above_sample_delta_h / sample_delta_h,
                                          below_sample_delta_h / sample_delta_h);

    float sample_h = getSampleToHeight(uvw_w);
    float target_stable_temp = getReferenceDegree(params.controls.sea_level_temperature, sample_h);

    ivec3 slc = local_coords + 2;
    vec2 src_temp_moist = loadAndUpdateTempMoist(pixel_coords, s_air_pressure_grid[slc.z][slc.y][slc.x]);

    vec2 updated_temp_moist = src_temp_moist + temp_moist_adj;

    float cur_temp = mix(updated_temp_moist.x, src_temp_moist.x, 0.0f);
    float cur_moist = mix(updated_temp_moist.y, src_temp_moist.y, 0.8f);
    imageStore(dst_temp_moisture,
               pixel_coords,
               vec4(normalizeTemperature(cur_temp), normalizeMoisture(cur_moist), 0, 0));

    vec4 src_airflow = imageLoad(dst_airflow, pixel_coords);
    vec3 src_airflow_dir = src_airflow.xyz * 2.0f - 1.0f;
    airflow_dir = mix(airflow_dir, src_airflow_dir * getPackedVectorLength(src_airflow.w), params.controls.mix_rate);
    float new_airflow_str = getNormalizedVectorLength(airflow_dir);
    imageStore(dst_airflow, pixel_coords, vec4(normalize(airflow_dir) * 0.5f + 0.5f, new_airflow_str));
}