#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "noise.glsl.h"

// reference : https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-26-implementing-improved-perlin-noise

layout(push_constant) uniform PerlinNoiseUniformBufferObject {
  PerlinNoiseInitParams params;
};

float3 fade(float3 t) {
	return t * t * t * (t * (t * 6 - 15) + 10); // new curve
	//  return t * t * (3 - 2 * t); // old curve
}

float perm(float x) {
	return tex1D(permSampler, x / 256.0) * 256;
}

float grad(float x, float3 p) {
	return dot(tex1D(gradSampler, x), p);
}

// 3D version
float inoise(float3 p) {
	float3 P = fmod(floor(p), 256.0);
	p -= floor(p);
	float3 f = fade(p);
	// HASH COORDINATES FOR 6 OF THE 8 CUBE CORNERS
	float A = perm(P.x) + P.y;
	float AA = perm(A) + P.z;
	float AB = perm(A + 1) + P.z;
	float B =  perm(P.x + 1) + P.y;
	float BA = perm(B) + P.z;
	float BB = perm(B + 1) + P.z;

	// AND ADD BLENDED RESULTS FROM 8 CORNERS OF CUBE
	return lerp(
				lerp(lerp(grad(perm(AA), p),
						  grad(perm(BA), p + float3(-1, 0, 0)), f.x),
				 	 lerp(grad(perm(AB), p + float3(0, -1, 0)),
						  grad(perm(BB), p + float3(-1, -1, 0)), f.x), f.y),
				lerp(lerp(grad(perm(AA + 1), p + float3(0, 0, -1)),
						  grad(perm(BA + 1), p + float3(-1, 0, -1)), f.x),
				     lerp(grad(perm(AB + 1), p + float3(0, -1, -1)),
						  grad(perm(BB + 1), p + float3(-1, -1, -1)), f.x), f.y), f.z);
}

layout(set = 0, binding = DST_PERLIN_NOISE_TEX_INDEX, r8) uniform writeonly image3D dst_perlin_noise;

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;
void main()
{
	// skip 2 lines on border.
	ivec3 pixel_coords = ivec3(gl_GlobalInvocationID.xyz);
	vec2 noise_value = hash23(vec3(pixel_coords));
	imageStore(dst_perlin_noise, pixel_coords, vec4(noise_value.xyy, 0.0f));
}