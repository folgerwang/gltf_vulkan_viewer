#version 460
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "tile_common.glsl.h"

layout(push_constant) uniform TileUniformBufferObject {
  TileParams tile_params;
};

layout(std430, set = 0, binding = VERTEX_BUFFER_INDEX) buffer TileVertexInfoBuffer {
  TileVertexInfo vertex_info[];
};

layout(set = 0, binding = ROCK_LAYER_BUFFER_INDEX, r16_snorm) uniform writeonly image2D rock_layer;
layout(set = 0, binding = SOIL_LAYER_BUFFER_INDEX, r16) uniform writeonly image2D soil_layer;
layout(set = 0, binding = WATER_LAYER_BUFFER_INDEX, r16) uniform writeonly image2D water_layer;
layout(set = 0, binding = GRASS_SNOW_LAYER_BUFFER_INDEX, rg8) uniform writeonly image2D grass_snow_layer;

layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
  // get index in global work group i.e x,y position
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  if (all(lessThanEqual(pixel_coords, uvec2(tile_params.segment_count)))) {
    int tile_size = int(tile_params.segment_count) + 1;
    int index = pixel_coords.y * tile_size + pixel_coords.x;
    float inv_segment_count = 1.0f / tile_params.segment_count;
    float factor_x = pixel_coords.x * inv_segment_count;
    float factor_y = pixel_coords.y * inv_segment_count;

    float x = tile_params.min.x + factor_x * (tile_params.max.x - tile_params.min.x);
    float y = tile_params.min.y + factor_y * (tile_params.max.y - tile_params.min.y);

    vec2 height_info = terrainMap(vec2(x, y));
    vertex_info[tile_params.offset + index].packed_land_layers =
        packTerrainLayers(vec4(height_info.x + ROCK_LAYER_BASE, 0, 5.0f, 0), 0);
  }
}